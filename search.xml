<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>创建博客的目的</title>
    <url>/2022/08/03/init/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>因为本身作者的学习的经历，所以学习和总结的知识比较的杂，比如说我可以写一些机构设计（3D建模）的内容，也可以写一些关于电路板设计的内容，最后比较难的<strong>嵌入式内容</strong></p>
<p>但是从自身的经历来说，贪多嚼不烂，后面主要分享的可能就是苦逼的写bug（bushi）的内容了。</p>
<h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><h3 id="stm32初级开发"><a href="#stm32初级开发" class="headerlink" title="stm32初级开发"></a>stm32初级开发</h3><ul>
<li>固件库开发</li>
<li>hal库</li>
<li>硬件仿真</li>
</ul>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>git入门</title>
    <url>/2022/08/04/git%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="git介绍"><a href="#git介绍" class="headerlink" title="git介绍"></a>git介绍</h2><p>Git是什么？Git是目前世界上最先进的分布式版本控制系统（没有之一）。Git有什么特点？简单来说就是：高端大气上档次！</p>
<h2 id="版本库介绍"><a href="#版本库介绍" class="headerlink" title="版本库介绍"></a>版本库介绍</h2><p>什么是版本库呢？版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p>
<h2 id="git基础的命令"><a href="#git基础的命令" class="headerlink" title="git基础的命令"></a>git基础的命令</h2><p>1.创建工作目录</p>
<blockquote>
<p>mkdir learngit        #创建文件夹<br>cd learngit           #转到learngit文件夹的目录<br>pwd                   #显示路径</p>
</blockquote>
<p>2.通过git init命令把这个目录变成Git可以管理的仓库</p>
<blockquote>
<p>$ git init<br>Initialized empty Git repository in &#x2F;Users&#x2F;michael&#x2F;learngit&#x2F;.git&#x2F;</p>
</blockquote>
<p>3.添加与提交</p>
<blockquote>
<p>git add readme.txt     #进行提交文件，应该在缓存<br>git commit             #用命令git commit告诉Git，把文件提交到仓库<br>git commit -m “wrote a readme file”  #提交时有信息</p>
</blockquote>
<h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><p><strong>使用命令git add <file>，注意，可反复多次使用，添加多个文件；使用命令git commit -m <message>，完成。</strong></p>
<span id="more"></span>
<h1 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h1><h2 id="git版本回溯"><a href="#git版本回溯" class="headerlink" title="git版本回溯"></a>git版本回溯</h2><h3 id="git版本回溯命令"><a href="#git版本回溯命令" class="headerlink" title="git版本回溯命令"></a>git版本回溯命令</h3><blockquote>
<p>git log                    #简短的版本信息<br>git log –pretty&#x3D;oneline   #经过处理的版本信息</p>
</blockquote>
<p><strong>首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交1094adb…（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。</strong></p>
<blockquote>
<p>git reset –hard HEAD^     #回溯到前一个版本（HEAD相当于指针）<br>git log                    #命令显示从最近到最远的提交日志<br>git reflog                 #方便找到每次提交的版本号</p>
</blockquote>
<h3 id="指针的示意图："><a href="#指针的示意图：" class="headerlink" title="指针的示意图："></a>指针的示意图：</h3><p>1.HEAD从指向append GPL<br>┌────┐<br>│HEAD│<br>└────┘<br>   │<br>   └──&gt; ○ append GPL<br>        │<br>        ○ add distributed<br>        │<br>        ○ wrote a readme file<br>2.改为指向add distributed<br>┌────┐<br>│HEAD│<br>└────┘<br>   │<br>   │    ○ append GPL<br>   │    │<br>   └──&gt; ○ add distributed<br>        │<br>        ○ wrote a readme file</p>
<p><em>HEAD指向哪个版本号，你就把当前版本定位在哪，以此实现版本的更新的保存和回退</em></p>
<h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><ul>
<li>HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset –hard commit_id。</li>
<li>穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。</li>
<li>要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。</li>
</ul>
<h2 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>1.版本库（Repository）<br>工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。<br>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。<br>2.文件添加进git版本库的过程</p>
<ul>
<li>第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区</li>
<li>第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。<br><em>因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。</em><br><em>可以多次添加，最后统一把缓存区的文件提交到分支上</em></li>
</ul>
<h3 id="git命令"><a href="#git命令" class="headerlink" title="git命令"></a>git命令</h3><blockquote>
<p>git status    #查看工作文件夹的状态,如果有修改未提交(git add)，则会报错</p>
</blockquote>
<h3 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h3><p>1.git commit 提交到分支的内容是暂存区的内容，有修改必须git add ,不然会产生报错，当前文件的内容和分支上的内容不相符<br>2.git diff HEAD – readme.txt命令可以查看工作区和版本库里面最新版本的区别</p>
<h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><p>1.情况一：readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p>
<blockquote>
<p>git checkout – file</p>
</blockquote>
<p><em>命令中的–很重要，没有–，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到git checkout命令</em></p>
<p>2.情况2：readme.txt  #已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态</p>
<blockquote>
<p>git reset HEAD <file>可以把暂存区的修改撤销掉（unstage），重新放回工作区：<br>git checkout – readme.txt  #丢弃工作区的修改</p>
</blockquote>
<p>3.小结</p>
<ul>
<li><p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout – file。</p>
</li>
<li><p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD <file>，就回到了场景1，第二步按场景1操作。</p>
</li>
<li><p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。</p>
</li>
</ul>
<h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p>1.git命令</p>
<blockquote>
<p>rm <file>      #删除工作目录中的文件<br>git rm <file>  #删除版本库中的文件（一般必须工作目录中也没有这个文件）<br>git checkout – test.txt #解决误删的情况</p>
</blockquote>
<p><em>git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</em></p>
<p>2.小结<br>命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。</p>
<h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><h2 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h2><p>1.远程仓库介绍<br>集中式版本控制系统SVN也可以完成上面功能，去解决文件备份或者丢失的问题<br>git的优势：Git是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。怎么分布呢？最早，肯定只有一台机器有一个原始版本库，此后，别的机器可以“克隆”这个原始版本库，而且每台机器的版本库其实都是一样的，并没有主次之分。<br>实际情况往往是这样，找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。<br><strong>Github</strong>就充当了代码托管的功能<br>2.git命令</p>
<ul>
<li><blockquote>
<p>ssh-keygen -t rsa -C “<a href="mailto:&#x79;&#111;&#x75;&#x72;&#x65;&#x6d;&#97;&#105;&#108;&#64;&#x65;&#x78;&#x61;&#109;&#x70;&#x6c;&#x65;&#46;&#x63;&#111;&#109;">&#x79;&#111;&#x75;&#x72;&#x65;&#x6d;&#97;&#105;&#108;&#64;&#x65;&#x78;&#x61;&#109;&#x70;&#x6c;&#x65;&#46;&#x63;&#111;&#109;</a>“ #ssh绑定</p>
</blockquote>
</li>
<li><blockquote>
<p>git remote add origin <a href="mailto:&#103;&#105;&#x74;&#x40;&#x67;&#x69;&#x74;&#104;&#117;&#98;&#46;&#x63;&#111;&#109;">&#103;&#105;&#x74;&#x40;&#x67;&#x69;&#x74;&#104;&#117;&#98;&#46;&#x63;&#111;&#109;</a>:michaelliao&#x2F;learngit.git #将本地仓库建立联系,origin相当于别名，可以起别的名字</p>
</blockquote>
</li>
<li><blockquote>
<p>git push -u origin master #本地库的所有内容推送到远程库上</p>
</blockquote>
</li>
</ul>
<p><em>由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。</em><br><em>以上内容第一次连接及推送时需要，后面就可以简化命令了</em></p>
<ul>
<li><blockquote>
<p>git pull –rebase origin master 将github修改的文件更新到本地</p>
</blockquote>
</li>
<li><blockquote>
<p>git push origin master 简化的推送远程仓库的命令</p>
</blockquote>
</li>
</ul>
<p><em>大多数时候由于本地库和远程库的更新进度不同，可以利用先pull再push来解决</em></p>
<h2 id="删除远程库"><a href="#删除远程库" class="headerlink" title="删除远程库"></a>删除远程库</h2><p>1.git命令</p>
<ul>
<li><blockquote>
<p>git remote -v        #查看远程库信息</p>
</blockquote>
</li>
<li><blockquote>
<p>git remote rm <name> #大多数时候name为origin，而不是GitHub中仓库的名字</p>
</blockquote>
</li>
</ul>
<p><em>分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！</em></p>
<h2 id="克隆远程库"><a href="#克隆远程库" class="headerlink" title="克隆远程库"></a>克隆远程库</h2><p>1.git命令</p>
<ul>
<li><blockquote>
<p>$ git clone <a href="mailto:&#103;&#x69;&#x74;&#x40;&#x67;&#105;&#116;&#x68;&#117;&#x62;&#x2e;&#x63;&#x6f;&#x6d;">&#103;&#x69;&#x74;&#x40;&#x67;&#105;&#116;&#x68;&#117;&#x62;&#x2e;&#x63;&#x6f;&#x6d;</a>:michaelliao&#x2F;gitskills.git</p>
</blockquote>
</li>
</ul>
<p>2.小结</p>
<ul>
<li><p>git常用协议为<a href="mailto:&#103;&#x69;&#x74;&#x40;&#x67;&#x69;&#116;&#104;&#117;&#98;&#46;&#x63;&#111;&#x6d;">&#103;&#x69;&#x74;&#x40;&#x67;&#x69;&#116;&#104;&#117;&#98;&#46;&#x63;&#111;&#x6d;</a>，但GitHub给出的地址不止一个，还可以用<a href="https://github.com/michaelliao/gitskills.git%E8%BF%99%E6%A0%B7%E7%9A%84%E5%9C%B0%E5%9D%80%E3%80%82%E5%AE%9E%E9%99%85%E4%B8%8A%EF%BC%8CGit%E6%94%AF%E6%8C%81%E5%A4%9A%E7%A7%8D%E5%8D%8F%E8%AE%AE%EF%BC%8C%E9%BB%98%E8%AE%A4%E7%9A%84git://%E4%BD%BF%E7%94%A8ssh%EF%BC%8C%E4%BD%86%E4%B9%9F%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8https%E7%AD%89%E5%85%B6%E4%BB%96%E5%8D%8F%E8%AE%AE%E3%80%82">https://github.com/michaelliao/gitskills.git这样的地址。实际上，Git支持多种协议，默认的git://使用ssh，但也可以使用https等其他协议。</a></p>
</li>
<li><p>使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https</p>
</li>
<li><p>要克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆。Git支持多种协议，包括https，但ssh协议速度最快。</p>
</li>
</ul>
<h1 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul>
<li>分支的作用：在团队或自己做的一个大型的项目中，你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。</li>
<li>具体应用举例：一个单片机工程中去修改一个外设的应用或配置时</li>
<li>git的优势：无论创建、切换和删除分支，Git在1秒钟之内就能完成！无论你的版本库是1个文件还是1万个文件。</li>
</ul>
<h2 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h2><p><em>题外话：个人感觉分支的内容有些难以理解，我第一次学的时候也没有搞懂，但是时隔一年之后，我现在学完了算法与数据结构（依托于c语言），感觉比较的熟悉，对于这个内容</em></p>
<h3 id="git命令-1"><a href="#git命令-1" class="headerlink" title="git命令"></a>git命令</h3><p>1.创建dev分支，然后切换到dev分支</p>
<blockquote>
<p>git checkout -b dev</p>
</blockquote>
<p><em>git checkout命令加上-b参数表示创建并切换，相当于以下两条命令:</em> </p>
<blockquote>
<p>git branch dev</p>
</blockquote>
<blockquote>
<p>git checkout dev</p>
</blockquote>
<p>2.然后，用git branch命令查看当前分支：</p>
<blockquote>
<p>git branch<br>*dev<br> master</p>
</blockquote>
<p><em>git branch命令会列出所有分支，当前分支前面会标一个</em>号</p>
<p>3.修改并提交文件</p>
<blockquote>
<p>$ git add readme.txt<br>$ git commit -m “branch test”</p>
</blockquote>
<p>4.现在，dev分支的工作完成，我们就可以切换回master分支</p>
<blockquote>
<p>git checkout master</p>
</blockquote>
<p><em>切换回master分支后，再查看一个readme.txt文件，刚才添加的内容不见了！因为那个提交是在dev分支上，而master分支此刻的提交点并没有变：</em></p>
<p>5.现在，我们把dev分支的工作成果合并到master分支上：</p>
<blockquote>
<p>git merge dev</p>
</blockquote>
<p><em>git merge命令用于合并指定分支到当前分支。合并后，再查看readme.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。当然，也不是每次合并都能Fast-forward，我们后面会讲其他方式的合并。</em></p>
<p><em>git merge语句中，需要注意的是那个指针指向另外一个指针指向的位置</em></p>
<p><em>git merge合并指定分支到当前分支，及将当前分支的指针指向我们选择的指定分支所指向的内容</em></p>
<p>6.合并完成后，就可以放心地删除dev分支了</p>
<blockquote>
<p>git branch -d dev</p>
</blockquote>
<p>7.删除后，查看branch，就只剩下master分支了</p>
<blockquote>
<p>git branch -d dev</p>
</blockquote>
<h3 id="额外的转换分支指令-switch"><a href="#额外的转换分支指令-switch" class="headerlink" title="额外的转换分支指令 switch"></a>额外的转换分支指令 switch</h3><p>1.创建并切换到新的dev分支，可以使用</p>
<blockquote>
<p>git switch -c dev<br>2.直接切换到已有的master分支，可以使用：<br>git switch master</p>
</blockquote>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>查看分支：git branch</p>
<p>创建分支：git branch <name></p>
<p>切换分支：git checkout <name>或者git switch <name></p>
<p>创建+切换分支：git checkout -b <name>或者git switch -c <name></p>
<p>合并某分支到当前分支：git merge <name></p>
<p>删除分支：git branch -d <name></p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>学习stm32前必备的知识</title>
    <url>/2022/08/03/%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>假如在学习stm32前，你学过51单片机，当然最好是在工科的专业在学校里面系统学习一遍，<del>当然不排除有天才少年</del>，如果你真的是可以把单片机的储存器深刻的理解了，外加着中断系统，外部中断，定时器，串口通信的原理搞懂，我相信学习stm32的时候你一定会非常的轻松。</p>
<p>如果是没学过的51单片机的，我个人认为最好学完51单片机之后再入门stm32。有些人可能对自己的未来有着很高期望的，做事情总是容易很浮躁。从我的经历来说，如果你静不下心来，那么做什么事情都不会做好的。这也是学stm32的一个思想，不要贪多，一天学一个，量变产生质变，最迟大概一个月就可以学完。</p>
<h2 id="stm32的开发前的准备"><a href="#stm32的开发前的准备" class="headerlink" title="stm32的开发前的准备"></a>stm32的开发前的准备</h2><p>1.开发的资料</p>
<ul>
<li>STM32F1xx中文参考手册.pdf</li>
<li>STM32固件库使用手册(中文翻译版).pdf</li>
<li>普中STM32F1xx开发攻略v1.0.pdf</li>
</ul>
<p><strong>如果开发stm32入门之后，你会发现你的c语言功底根本不够，推荐浙大翁恺教授的c语言，你会真正理解 结构体、枚举、头文件、编译预处理…</strong></p>
<p>2.开发用的IDE</p>
<ul>
<li>KEIL 5 (虽然界面不好看，但是真的好用，永远不要知道什么是ccs、iar)</li>
<li>VScode （界面好看一些，一般作为keil 5 的辅助工具）</li>
</ul>
]]></content>
      <tags>
        <tag>stm32</tag>
      </tags>
  </entry>
</search>
